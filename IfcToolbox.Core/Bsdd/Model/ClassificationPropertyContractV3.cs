/* 
 * bSDD API prototype
 *
 * API to access the buildingSMART Data Dictionary
 *
 * OpenAPI spec version: v1
 * Contact: bsdd_support@buildingsmart.org
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 */
using System;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Runtime.Serialization;
using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System.ComponentModel.DataAnnotations;
using SwaggerDateConverter = IO.Swagger.Client.SwaggerDateConverter;

namespace IO.Swagger.Model
{
    /// <summary>
    /// ClassificationPropertyContractV3
    /// </summary>
    [DataContract]
        public partial class ClassificationPropertyContractV3 :  IEquatable<ClassificationPropertyContractV3>, IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="ClassificationPropertyContractV3" /> class.
        /// </summary>
        /// <param name="name">Name of the property (required).</param>
        /// <param name="description">Plain language description of the property.  If at Property level no description has been given but a \&quot;Definition\&quot; is available, then \&quot;Definition\&quot; is returned as description.</param>
        /// <param name="dataType">Format for expressing the value of the property.</param>
        /// <param name="dimension">Dimension of the physical quantity in format \&quot;L M T I Θ N J\&quot;, for example \&quot;-2 1 0 0 0 0 0\&quot;.  With    L   Length    M   Mass    T   Time    I   Electric current    Θ   Thermodynamic Temperature    N   Amount of substance    J   Luminous intensity.</param>
        /// <param name="dimensionLength">The Length value of the dimension.</param>
        /// <param name="dimensionMass">The Mass value of the dimension.</param>
        /// <param name="dimensionTime">The Time value of the dimension.</param>
        /// <param name="dimensionElectricCurrent">The Electric current value of the dimension.</param>
        /// <param name="dimensionThermodynamicTemperature">The Thermodynamic temperature value of the dimension.</param>
        /// <param name="dimensionAmountOfSubstance">The Amount of substance value of the dimension.</param>
        /// <param name="dimensionLuminousIntensity">The Luminous intensity value of the dimension.</param>
        /// <param name="dynamicParameterPropertyCodes">List of codes of the properties which are parameters of the function for a dynamic property.  Only applicable for dynamic properties (IsDynamic).</param>
        /// <param name="example">Illustrate possible use or values of the Property.</param>
        /// <param name="isDynamic">True if the value of this property is dependent on other properties (as provided in DynamicParameterPropertyCodes).</param>
        /// <param name="isRequired">Indicates if this property is required for the classification.</param>
        /// <param name="isWritable">Indicates if the value of the property can be changed by the user.</param>
        /// <param name="maxExclusive">Maximum value of the property, exclusive  This value does not need to be the same as the MaxExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value..</param>
        /// <param name="maxInclusive">Maximum value of the property, inclusive  This value does not need to be the same as the MaxInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value..</param>
        /// <param name="minExclusive">Minimum value of the property, exclusive  This value does not need to be the same as the MinExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value..</param>
        /// <param name="minInclusive">Minimum value of the property, inclusive  This value does not need to be the same as the MinInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value..</param>
        /// <param name="pattern">An XML Schema Regular expression for the property value.  See for explanation: https://www.regular-expressions.info/xml.html.  This value does not need to be the same as the Pattern in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value..</param>
        /// <param name="physicalQuantity">The quantity in plain text.</param>
        /// <param name="possibleValues">List of possible values  This list does not need to be the same as the list of PossibleValues in the Property contract  because this list can be overruled at Classification-Property level to define a more strict list..</param>
        /// <param name="predefinedValue">Predefined value: if the classification can have only one value for this property, this is it.</param>
        /// <param name="propertyCode">Code of the property, only applicable if property is of the same domain as the classification..</param>
        /// <param name="propertyDomainName">Name of the Domain this property belongs to.</param>
        /// <param name="propertyNamespaceUri">Unique identification of the property.</param>
        /// <param name="propertySet">Name of the Property Set.</param>
        /// <param name="propertyStatus">Status of the property: Preview, Active or Inactive.</param>
        /// <param name="propertyValueKind">Indicates kind of value: Single, Range (2 values expected), List (multiple values expected), Complex (use in combination with \&quot;ConnectedProperties\&quot;), ComplexList.</param>
        /// <param name="symbol">Symbol of the property.</param>
        /// <param name="units">List of units to select from.</param>
        public ClassificationPropertyContractV3(string name = default(string), string description = default(string), string dataType = default(string), string dimension = default(string), int? dimensionLength = default(int?), int? dimensionMass = default(int?), int? dimensionTime = default(int?), int? dimensionElectricCurrent = default(int?), int? dimensionThermodynamicTemperature = default(int?), int? dimensionAmountOfSubstance = default(int?), int? dimensionLuminousIntensity = default(int?), List<string> dynamicParameterPropertyCodes = default(List<string>), string example = default(string), bool? isDynamic = default(bool?), bool? isRequired = default(bool?), bool? isWritable = default(bool?), double? maxExclusive = default(double?), double? maxInclusive = default(double?), double? minExclusive = default(double?), double? minInclusive = default(double?), string pattern = default(string), string physicalQuantity = default(string), List<ClassificationPropertyValueContractV3> possibleValues = default(List<ClassificationPropertyValueContractV3>), string predefinedValue = default(string), string propertyCode = default(string), string propertyDomainName = default(string), string propertyNamespaceUri = default(string), string propertySet = default(string), string propertyStatus = default(string), string propertyValueKind = default(string), string symbol = default(string), List<string> units = default(List<string>))
        {
            // to ensure "name" is required (not null)
            if (name == null)
            {
                throw new InvalidDataException("name is a required property for ClassificationPropertyContractV3 and cannot be null");
            }
            else
            {
                this.Name = name;
            }
            this.Description = description;
            this.DataType = dataType;
            this.Dimension = dimension;
            this.DimensionLength = dimensionLength;
            this.DimensionMass = dimensionMass;
            this.DimensionTime = dimensionTime;
            this.DimensionElectricCurrent = dimensionElectricCurrent;
            this.DimensionThermodynamicTemperature = dimensionThermodynamicTemperature;
            this.DimensionAmountOfSubstance = dimensionAmountOfSubstance;
            this.DimensionLuminousIntensity = dimensionLuminousIntensity;
            this.DynamicParameterPropertyCodes = dynamicParameterPropertyCodes;
            this.Example = example;
            this.IsDynamic = isDynamic;
            this.IsRequired = isRequired;
            this.IsWritable = isWritable;
            this.MaxExclusive = maxExclusive;
            this.MaxInclusive = maxInclusive;
            this.MinExclusive = minExclusive;
            this.MinInclusive = minInclusive;
            this.Pattern = pattern;
            this.PhysicalQuantity = physicalQuantity;
            this.PossibleValues = possibleValues;
            this.PredefinedValue = predefinedValue;
            this.PropertyCode = propertyCode;
            this.PropertyDomainName = propertyDomainName;
            this.PropertyNamespaceUri = propertyNamespaceUri;
            this.PropertySet = propertySet;
            this.PropertyStatus = propertyStatus;
            this.PropertyValueKind = propertyValueKind;
            this.Symbol = symbol;
            this.Units = units;
        }
        
        /// <summary>
        /// Name of the property
        /// </summary>
        /// <value>Name of the property</value>
        [DataMember(Name="name", EmitDefaultValue=false)]
        public string Name { get; set; }

        /// <summary>
        /// Plain language description of the property.  If at Property level no description has been given but a \&quot;Definition\&quot; is available, then \&quot;Definition\&quot; is returned as description
        /// </summary>
        /// <value>Plain language description of the property.  If at Property level no description has been given but a \&quot;Definition\&quot; is available, then \&quot;Definition\&quot; is returned as description</value>
        [DataMember(Name="description", EmitDefaultValue=false)]
        public string Description { get; set; }

        /// <summary>
        /// Format for expressing the value of the property
        /// </summary>
        /// <value>Format for expressing the value of the property</value>
        [DataMember(Name="dataType", EmitDefaultValue=false)]
        public string DataType { get; set; }

        /// <summary>
        /// Dimension of the physical quantity in format \&quot;L M T I Θ N J\&quot;, for example \&quot;-2 1 0 0 0 0 0\&quot;.  With    L   Length    M   Mass    T   Time    I   Electric current    Θ   Thermodynamic Temperature    N   Amount of substance    J   Luminous intensity
        /// </summary>
        /// <value>Dimension of the physical quantity in format \&quot;L M T I Θ N J\&quot;, for example \&quot;-2 1 0 0 0 0 0\&quot;.  With    L   Length    M   Mass    T   Time    I   Electric current    Θ   Thermodynamic Temperature    N   Amount of substance    J   Luminous intensity</value>
        [DataMember(Name="dimension", EmitDefaultValue=false)]
        public string Dimension { get; set; }

        /// <summary>
        /// The Length value of the dimension
        /// </summary>
        /// <value>The Length value of the dimension</value>
        [DataMember(Name="dimensionLength", EmitDefaultValue=false)]
        public int? DimensionLength { get; set; }

        /// <summary>
        /// The Mass value of the dimension
        /// </summary>
        /// <value>The Mass value of the dimension</value>
        [DataMember(Name="dimensionMass", EmitDefaultValue=false)]
        public int? DimensionMass { get; set; }

        /// <summary>
        /// The Time value of the dimension
        /// </summary>
        /// <value>The Time value of the dimension</value>
        [DataMember(Name="dimensionTime", EmitDefaultValue=false)]
        public int? DimensionTime { get; set; }

        /// <summary>
        /// The Electric current value of the dimension
        /// </summary>
        /// <value>The Electric current value of the dimension</value>
        [DataMember(Name="dimensionElectricCurrent", EmitDefaultValue=false)]
        public int? DimensionElectricCurrent { get; set; }

        /// <summary>
        /// The Thermodynamic temperature value of the dimension
        /// </summary>
        /// <value>The Thermodynamic temperature value of the dimension</value>
        [DataMember(Name="dimensionThermodynamicTemperature", EmitDefaultValue=false)]
        public int? DimensionThermodynamicTemperature { get; set; }

        /// <summary>
        /// The Amount of substance value of the dimension
        /// </summary>
        /// <value>The Amount of substance value of the dimension</value>
        [DataMember(Name="dimensionAmountOfSubstance", EmitDefaultValue=false)]
        public int? DimensionAmountOfSubstance { get; set; }

        /// <summary>
        /// The Luminous intensity value of the dimension
        /// </summary>
        /// <value>The Luminous intensity value of the dimension</value>
        [DataMember(Name="dimensionLuminousIntensity", EmitDefaultValue=false)]
        public int? DimensionLuminousIntensity { get; set; }

        /// <summary>
        /// List of codes of the properties which are parameters of the function for a dynamic property.  Only applicable for dynamic properties (IsDynamic)
        /// </summary>
        /// <value>List of codes of the properties which are parameters of the function for a dynamic property.  Only applicable for dynamic properties (IsDynamic)</value>
        [DataMember(Name="dynamicParameterPropertyCodes", EmitDefaultValue=false)]
        public List<string> DynamicParameterPropertyCodes { get; set; }

        /// <summary>
        /// Illustrate possible use or values of the Property
        /// </summary>
        /// <value>Illustrate possible use or values of the Property</value>
        [DataMember(Name="example", EmitDefaultValue=false)]
        public string Example { get; set; }

        /// <summary>
        /// True if the value of this property is dependent on other properties (as provided in DynamicParameterPropertyCodes)
        /// </summary>
        /// <value>True if the value of this property is dependent on other properties (as provided in DynamicParameterPropertyCodes)</value>
        [DataMember(Name="isDynamic", EmitDefaultValue=false)]
        public bool? IsDynamic { get; set; }

        /// <summary>
        /// Indicates if this property is required for the classification
        /// </summary>
        /// <value>Indicates if this property is required for the classification</value>
        [DataMember(Name="isRequired", EmitDefaultValue=false)]
        public bool? IsRequired { get; set; }

        /// <summary>
        /// Indicates if the value of the property can be changed by the user
        /// </summary>
        /// <value>Indicates if the value of the property can be changed by the user</value>
        [DataMember(Name="isWritable", EmitDefaultValue=false)]
        public bool? IsWritable { get; set; }

        /// <summary>
        /// Maximum value of the property, exclusive  This value does not need to be the same as the MaxExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
        /// </summary>
        /// <value>Maximum value of the property, exclusive  This value does not need to be the same as the MaxExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.</value>
        [DataMember(Name="maxExclusive", EmitDefaultValue=false)]
        public double? MaxExclusive { get; set; }

        /// <summary>
        /// Maximum value of the property, inclusive  This value does not need to be the same as the MaxInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
        /// </summary>
        /// <value>Maximum value of the property, inclusive  This value does not need to be the same as the MaxInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.</value>
        [DataMember(Name="maxInclusive", EmitDefaultValue=false)]
        public double? MaxInclusive { get; set; }

        /// <summary>
        /// Minimum value of the property, exclusive  This value does not need to be the same as the MinExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
        /// </summary>
        /// <value>Minimum value of the property, exclusive  This value does not need to be the same as the MinExclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.</value>
        [DataMember(Name="minExclusive", EmitDefaultValue=false)]
        public double? MinExclusive { get; set; }

        /// <summary>
        /// Minimum value of the property, inclusive  This value does not need to be the same as the MinInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
        /// </summary>
        /// <value>Minimum value of the property, inclusive  This value does not need to be the same as the MinInclusive in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.</value>
        [DataMember(Name="minInclusive", EmitDefaultValue=false)]
        public double? MinInclusive { get; set; }

        /// <summary>
        /// An XML Schema Regular expression for the property value.  See for explanation: https://www.regular-expressions.info/xml.html.  This value does not need to be the same as the Pattern in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.
        /// </summary>
        /// <value>An XML Schema Regular expression for the property value.  See for explanation: https://www.regular-expressions.info/xml.html.  This value does not need to be the same as the Pattern in the Property contract  because this value can be overruled at Classification-Property level to define a more strict value.</value>
        [DataMember(Name="pattern", EmitDefaultValue=false)]
        public string Pattern { get; set; }

        /// <summary>
        /// The quantity in plain text
        /// </summary>
        /// <value>The quantity in plain text</value>
        [DataMember(Name="physicalQuantity", EmitDefaultValue=false)]
        public string PhysicalQuantity { get; set; }

        /// <summary>
        /// List of possible values  This list does not need to be the same as the list of PossibleValues in the Property contract  because this list can be overruled at Classification-Property level to define a more strict list.
        /// </summary>
        /// <value>List of possible values  This list does not need to be the same as the list of PossibleValues in the Property contract  because this list can be overruled at Classification-Property level to define a more strict list.</value>
        [DataMember(Name="possibleValues", EmitDefaultValue=false)]
        public List<ClassificationPropertyValueContractV3> PossibleValues { get; set; }

        /// <summary>
        /// Predefined value: if the classification can have only one value for this property, this is it
        /// </summary>
        /// <value>Predefined value: if the classification can have only one value for this property, this is it</value>
        [DataMember(Name="predefinedValue", EmitDefaultValue=false)]
        public string PredefinedValue { get; set; }

        /// <summary>
        /// Code of the property, only applicable if property is of the same domain as the classification.
        /// </summary>
        /// <value>Code of the property, only applicable if property is of the same domain as the classification.</value>
        [DataMember(Name="propertyCode", EmitDefaultValue=false)]
        public string PropertyCode { get; set; }

        /// <summary>
        /// Name of the Domain this property belongs to
        /// </summary>
        /// <value>Name of the Domain this property belongs to</value>
        [DataMember(Name="propertyDomainName", EmitDefaultValue=false)]
        public string PropertyDomainName { get; set; }

        /// <summary>
        /// Unique identification of the property
        /// </summary>
        /// <value>Unique identification of the property</value>
        [DataMember(Name="propertyNamespaceUri", EmitDefaultValue=false)]
        public string PropertyNamespaceUri { get; set; }

        /// <summary>
        /// Name of the Property Set
        /// </summary>
        /// <value>Name of the Property Set</value>
        [DataMember(Name="propertySet", EmitDefaultValue=false)]
        public string PropertySet { get; set; }

        /// <summary>
        /// Status of the property: Preview, Active or Inactive
        /// </summary>
        /// <value>Status of the property: Preview, Active or Inactive</value>
        [DataMember(Name="propertyStatus", EmitDefaultValue=false)]
        public string PropertyStatus { get; set; }

        /// <summary>
        /// Indicates kind of value: Single, Range (2 values expected), List (multiple values expected), Complex (use in combination with \&quot;ConnectedProperties\&quot;), ComplexList
        /// </summary>
        /// <value>Indicates kind of value: Single, Range (2 values expected), List (multiple values expected), Complex (use in combination with \&quot;ConnectedProperties\&quot;), ComplexList</value>
        [DataMember(Name="propertyValueKind", EmitDefaultValue=false)]
        public string PropertyValueKind { get; set; }

        /// <summary>
        /// Symbol of the property
        /// </summary>
        /// <value>Symbol of the property</value>
        [DataMember(Name="symbol", EmitDefaultValue=false)]
        public string Symbol { get; set; }

        /// <summary>
        /// List of units to select from
        /// </summary>
        /// <value>List of units to select from</value>
        [DataMember(Name="units", EmitDefaultValue=false)]
        public List<string> Units { get; set; }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            var sb = new StringBuilder();
            sb.Append("class ClassificationPropertyContractV3 {\n");
            sb.Append("  Name: ").Append(Name).Append("\n");
            sb.Append("  Description: ").Append(Description).Append("\n");
            sb.Append("  DataType: ").Append(DataType).Append("\n");
            sb.Append("  Dimension: ").Append(Dimension).Append("\n");
            sb.Append("  DimensionLength: ").Append(DimensionLength).Append("\n");
            sb.Append("  DimensionMass: ").Append(DimensionMass).Append("\n");
            sb.Append("  DimensionTime: ").Append(DimensionTime).Append("\n");
            sb.Append("  DimensionElectricCurrent: ").Append(DimensionElectricCurrent).Append("\n");
            sb.Append("  DimensionThermodynamicTemperature: ").Append(DimensionThermodynamicTemperature).Append("\n");
            sb.Append("  DimensionAmountOfSubstance: ").Append(DimensionAmountOfSubstance).Append("\n");
            sb.Append("  DimensionLuminousIntensity: ").Append(DimensionLuminousIntensity).Append("\n");
            sb.Append("  DynamicParameterPropertyCodes: ").Append(DynamicParameterPropertyCodes).Append("\n");
            sb.Append("  Example: ").Append(Example).Append("\n");
            sb.Append("  IsDynamic: ").Append(IsDynamic).Append("\n");
            sb.Append("  IsRequired: ").Append(IsRequired).Append("\n");
            sb.Append("  IsWritable: ").Append(IsWritable).Append("\n");
            sb.Append("  MaxExclusive: ").Append(MaxExclusive).Append("\n");
            sb.Append("  MaxInclusive: ").Append(MaxInclusive).Append("\n");
            sb.Append("  MinExclusive: ").Append(MinExclusive).Append("\n");
            sb.Append("  MinInclusive: ").Append(MinInclusive).Append("\n");
            sb.Append("  Pattern: ").Append(Pattern).Append("\n");
            sb.Append("  PhysicalQuantity: ").Append(PhysicalQuantity).Append("\n");
            sb.Append("  PossibleValues: ").Append(PossibleValues).Append("\n");
            sb.Append("  PredefinedValue: ").Append(PredefinedValue).Append("\n");
            sb.Append("  PropertyCode: ").Append(PropertyCode).Append("\n");
            sb.Append("  PropertyDomainName: ").Append(PropertyDomainName).Append("\n");
            sb.Append("  PropertyNamespaceUri: ").Append(PropertyNamespaceUri).Append("\n");
            sb.Append("  PropertySet: ").Append(PropertySet).Append("\n");
            sb.Append("  PropertyStatus: ").Append(PropertyStatus).Append("\n");
            sb.Append("  PropertyValueKind: ").Append(PropertyValueKind).Append("\n");
            sb.Append("  Symbol: ").Append(Symbol).Append("\n");
            sb.Append("  Units: ").Append(Units).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }
  
        /// <summary>
        /// Returns the JSON string presentation of the object
        /// </summary>
        /// <returns>JSON string presentation of the object</returns>
        public virtual string ToJson()
        {
            return JsonConvert.SerializeObject(this, Formatting.Indented);
        }

        /// <summary>
        /// Returns true if objects are equal
        /// </summary>
        /// <param name="input">Object to be compared</param>
        /// <returns>Boolean</returns>
        public override bool Equals(object input)
        {
            return this.Equals(input as ClassificationPropertyContractV3);
        }

        /// <summary>
        /// Returns true if ClassificationPropertyContractV3 instances are equal
        /// </summary>
        /// <param name="input">Instance of ClassificationPropertyContractV3 to be compared</param>
        /// <returns>Boolean</returns>
        public bool Equals(ClassificationPropertyContractV3 input)
        {
            if (input == null)
                return false;

            return 
                (
                    this.Name == input.Name ||
                    (this.Name != null &&
                    this.Name.Equals(input.Name))
                ) && 
                (
                    this.Description == input.Description ||
                    (this.Description != null &&
                    this.Description.Equals(input.Description))
                ) && 
                (
                    this.DataType == input.DataType ||
                    (this.DataType != null &&
                    this.DataType.Equals(input.DataType))
                ) && 
                (
                    this.Dimension == input.Dimension ||
                    (this.Dimension != null &&
                    this.Dimension.Equals(input.Dimension))
                ) && 
                (
                    this.DimensionLength == input.DimensionLength ||
                    (this.DimensionLength != null &&
                    this.DimensionLength.Equals(input.DimensionLength))
                ) && 
                (
                    this.DimensionMass == input.DimensionMass ||
                    (this.DimensionMass != null &&
                    this.DimensionMass.Equals(input.DimensionMass))
                ) && 
                (
                    this.DimensionTime == input.DimensionTime ||
                    (this.DimensionTime != null &&
                    this.DimensionTime.Equals(input.DimensionTime))
                ) && 
                (
                    this.DimensionElectricCurrent == input.DimensionElectricCurrent ||
                    (this.DimensionElectricCurrent != null &&
                    this.DimensionElectricCurrent.Equals(input.DimensionElectricCurrent))
                ) && 
                (
                    this.DimensionThermodynamicTemperature == input.DimensionThermodynamicTemperature ||
                    (this.DimensionThermodynamicTemperature != null &&
                    this.DimensionThermodynamicTemperature.Equals(input.DimensionThermodynamicTemperature))
                ) && 
                (
                    this.DimensionAmountOfSubstance == input.DimensionAmountOfSubstance ||
                    (this.DimensionAmountOfSubstance != null &&
                    this.DimensionAmountOfSubstance.Equals(input.DimensionAmountOfSubstance))
                ) && 
                (
                    this.DimensionLuminousIntensity == input.DimensionLuminousIntensity ||
                    (this.DimensionLuminousIntensity != null &&
                    this.DimensionLuminousIntensity.Equals(input.DimensionLuminousIntensity))
                ) && 
                (
                    this.DynamicParameterPropertyCodes == input.DynamicParameterPropertyCodes ||
                    this.DynamicParameterPropertyCodes != null &&
                    input.DynamicParameterPropertyCodes != null &&
                    this.DynamicParameterPropertyCodes.SequenceEqual(input.DynamicParameterPropertyCodes)
                ) && 
                (
                    this.Example == input.Example ||
                    (this.Example != null &&
                    this.Example.Equals(input.Example))
                ) && 
                (
                    this.IsDynamic == input.IsDynamic ||
                    (this.IsDynamic != null &&
                    this.IsDynamic.Equals(input.IsDynamic))
                ) && 
                (
                    this.IsRequired == input.IsRequired ||
                    (this.IsRequired != null &&
                    this.IsRequired.Equals(input.IsRequired))
                ) && 
                (
                    this.IsWritable == input.IsWritable ||
                    (this.IsWritable != null &&
                    this.IsWritable.Equals(input.IsWritable))
                ) && 
                (
                    this.MaxExclusive == input.MaxExclusive ||
                    (this.MaxExclusive != null &&
                    this.MaxExclusive.Equals(input.MaxExclusive))
                ) && 
                (
                    this.MaxInclusive == input.MaxInclusive ||
                    (this.MaxInclusive != null &&
                    this.MaxInclusive.Equals(input.MaxInclusive))
                ) && 
                (
                    this.MinExclusive == input.MinExclusive ||
                    (this.MinExclusive != null &&
                    this.MinExclusive.Equals(input.MinExclusive))
                ) && 
                (
                    this.MinInclusive == input.MinInclusive ||
                    (this.MinInclusive != null &&
                    this.MinInclusive.Equals(input.MinInclusive))
                ) && 
                (
                    this.Pattern == input.Pattern ||
                    (this.Pattern != null &&
                    this.Pattern.Equals(input.Pattern))
                ) && 
                (
                    this.PhysicalQuantity == input.PhysicalQuantity ||
                    (this.PhysicalQuantity != null &&
                    this.PhysicalQuantity.Equals(input.PhysicalQuantity))
                ) && 
                (
                    this.PossibleValues == input.PossibleValues ||
                    this.PossibleValues != null &&
                    input.PossibleValues != null &&
                    this.PossibleValues.SequenceEqual(input.PossibleValues)
                ) && 
                (
                    this.PredefinedValue == input.PredefinedValue ||
                    (this.PredefinedValue != null &&
                    this.PredefinedValue.Equals(input.PredefinedValue))
                ) && 
                (
                    this.PropertyCode == input.PropertyCode ||
                    (this.PropertyCode != null &&
                    this.PropertyCode.Equals(input.PropertyCode))
                ) && 
                (
                    this.PropertyDomainName == input.PropertyDomainName ||
                    (this.PropertyDomainName != null &&
                    this.PropertyDomainName.Equals(input.PropertyDomainName))
                ) && 
                (
                    this.PropertyNamespaceUri == input.PropertyNamespaceUri ||
                    (this.PropertyNamespaceUri != null &&
                    this.PropertyNamespaceUri.Equals(input.PropertyNamespaceUri))
                ) && 
                (
                    this.PropertySet == input.PropertySet ||
                    (this.PropertySet != null &&
                    this.PropertySet.Equals(input.PropertySet))
                ) && 
                (
                    this.PropertyStatus == input.PropertyStatus ||
                    (this.PropertyStatus != null &&
                    this.PropertyStatus.Equals(input.PropertyStatus))
                ) && 
                (
                    this.PropertyValueKind == input.PropertyValueKind ||
                    (this.PropertyValueKind != null &&
                    this.PropertyValueKind.Equals(input.PropertyValueKind))
                ) && 
                (
                    this.Symbol == input.Symbol ||
                    (this.Symbol != null &&
                    this.Symbol.Equals(input.Symbol))
                ) && 
                (
                    this.Units == input.Units ||
                    this.Units != null &&
                    input.Units != null &&
                    this.Units.SequenceEqual(input.Units)
                );
        }

        /// <summary>
        /// Gets the hash code
        /// </summary>
        /// <returns>Hash code</returns>
        public override int GetHashCode()
        {
            unchecked // Overflow is fine, just wrap
            {
                int hashCode = 41;
                if (this.Name != null)
                    hashCode = hashCode * 59 + this.Name.GetHashCode();
                if (this.Description != null)
                    hashCode = hashCode * 59 + this.Description.GetHashCode();
                if (this.DataType != null)
                    hashCode = hashCode * 59 + this.DataType.GetHashCode();
                if (this.Dimension != null)
                    hashCode = hashCode * 59 + this.Dimension.GetHashCode();
                if (this.DimensionLength != null)
                    hashCode = hashCode * 59 + this.DimensionLength.GetHashCode();
                if (this.DimensionMass != null)
                    hashCode = hashCode * 59 + this.DimensionMass.GetHashCode();
                if (this.DimensionTime != null)
                    hashCode = hashCode * 59 + this.DimensionTime.GetHashCode();
                if (this.DimensionElectricCurrent != null)
                    hashCode = hashCode * 59 + this.DimensionElectricCurrent.GetHashCode();
                if (this.DimensionThermodynamicTemperature != null)
                    hashCode = hashCode * 59 + this.DimensionThermodynamicTemperature.GetHashCode();
                if (this.DimensionAmountOfSubstance != null)
                    hashCode = hashCode * 59 + this.DimensionAmountOfSubstance.GetHashCode();
                if (this.DimensionLuminousIntensity != null)
                    hashCode = hashCode * 59 + this.DimensionLuminousIntensity.GetHashCode();
                if (this.DynamicParameterPropertyCodes != null)
                    hashCode = hashCode * 59 + this.DynamicParameterPropertyCodes.GetHashCode();
                if (this.Example != null)
                    hashCode = hashCode * 59 + this.Example.GetHashCode();
                if (this.IsDynamic != null)
                    hashCode = hashCode * 59 + this.IsDynamic.GetHashCode();
                if (this.IsRequired != null)
                    hashCode = hashCode * 59 + this.IsRequired.GetHashCode();
                if (this.IsWritable != null)
                    hashCode = hashCode * 59 + this.IsWritable.GetHashCode();
                if (this.MaxExclusive != null)
                    hashCode = hashCode * 59 + this.MaxExclusive.GetHashCode();
                if (this.MaxInclusive != null)
                    hashCode = hashCode * 59 + this.MaxInclusive.GetHashCode();
                if (this.MinExclusive != null)
                    hashCode = hashCode * 59 + this.MinExclusive.GetHashCode();
                if (this.MinInclusive != null)
                    hashCode = hashCode * 59 + this.MinInclusive.GetHashCode();
                if (this.Pattern != null)
                    hashCode = hashCode * 59 + this.Pattern.GetHashCode();
                if (this.PhysicalQuantity != null)
                    hashCode = hashCode * 59 + this.PhysicalQuantity.GetHashCode();
                if (this.PossibleValues != null)
                    hashCode = hashCode * 59 + this.PossibleValues.GetHashCode();
                if (this.PredefinedValue != null)
                    hashCode = hashCode * 59 + this.PredefinedValue.GetHashCode();
                if (this.PropertyCode != null)
                    hashCode = hashCode * 59 + this.PropertyCode.GetHashCode();
                if (this.PropertyDomainName != null)
                    hashCode = hashCode * 59 + this.PropertyDomainName.GetHashCode();
                if (this.PropertyNamespaceUri != null)
                    hashCode = hashCode * 59 + this.PropertyNamespaceUri.GetHashCode();
                if (this.PropertySet != null)
                    hashCode = hashCode * 59 + this.PropertySet.GetHashCode();
                if (this.PropertyStatus != null)
                    hashCode = hashCode * 59 + this.PropertyStatus.GetHashCode();
                if (this.PropertyValueKind != null)
                    hashCode = hashCode * 59 + this.PropertyValueKind.GetHashCode();
                if (this.Symbol != null)
                    hashCode = hashCode * 59 + this.Symbol.GetHashCode();
                if (this.Units != null)
                    hashCode = hashCode * 59 + this.Units.GetHashCode();
                return hashCode;
            }
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<System.ComponentModel.DataAnnotations.ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }
}
